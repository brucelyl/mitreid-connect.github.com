<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ClientAPI.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">OpenID Connect Server Webapp</a> &gt; <a href="../index.html" class="el_bundle">openid-connect-server</a> &gt; <a href="index.source.html" class="el_package">org.mitre.openid.connect.web</a> &gt; <span class="el_source">ClientAPI.java</span></div><h1>ClientAPI.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright 2017 The MIT Internet Trust Consortium
 *
 * Portions copyright 2011-2013 The MITRE Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package org.mitre.openid.connect.web;

import java.lang.reflect.Type;
import java.sql.SQLIntegrityConstraintViolationException;
import java.text.ParseException;
import java.util.Collection;

import javax.persistence.PersistenceException;

import org.eclipse.persistence.exceptions.DatabaseException;
import org.mitre.jwt.assertion.AssertionValidator;
import org.mitre.oauth2.model.ClientDetailsEntity;
import org.mitre.oauth2.model.ClientDetailsEntity.AppType;
import org.mitre.oauth2.model.ClientDetailsEntity.AuthMethod;
import org.mitre.oauth2.model.ClientDetailsEntity.SubjectType;
import org.mitre.oauth2.model.PKCEAlgorithm;
import org.mitre.oauth2.service.ClientDetailsEntityService;
import org.mitre.oauth2.web.AuthenticationUtilities;
import org.mitre.openid.connect.exception.ValidationException;
import org.mitre.openid.connect.model.CachedImage;
import org.mitre.openid.connect.service.ClientLogoLoadingService;
import org.mitre.openid.connect.view.ClientEntityViewForAdmins;
import org.mitre.openid.connect.view.ClientEntityViewForUsers;
import org.mitre.openid.connect.view.HttpCodeView;
import org.mitre.openid.connect.view.JsonEntityView;
import org.mitre.openid.connect.view.JsonErrorView;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.common.util.OAuth2Utils;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.google.common.base.Strings;
import com.google.common.collect.Sets;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import com.nimbusds.jose.Algorithm;
import com.nimbusds.jose.EncryptionMethod;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.JWTParser;

import static org.mitre.oauth2.model.RegisteredClientFields.APPLICATION_TYPE;
import static org.mitre.oauth2.model.RegisteredClientFields.CLAIMS_REDIRECT_URIS;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_ID;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_ID_ISSUED_AT;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_NAME;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_SECRET;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_SECRET_EXPIRES_AT;
import static org.mitre.oauth2.model.RegisteredClientFields.CLIENT_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.CONTACTS;
import static org.mitre.oauth2.model.RegisteredClientFields.DEFAULT_ACR_VALUES;
import static org.mitre.oauth2.model.RegisteredClientFields.DEFAULT_MAX_AGE;
import static org.mitre.oauth2.model.RegisteredClientFields.GRANT_TYPES;
import static org.mitre.oauth2.model.RegisteredClientFields.ID_TOKEN_ENCRYPTED_RESPONSE_ALG;
import static org.mitre.oauth2.model.RegisteredClientFields.ID_TOKEN_ENCRYPTED_RESPONSE_ENC;
import static org.mitre.oauth2.model.RegisteredClientFields.ID_TOKEN_SIGNED_RESPONSE_ALG;
import static org.mitre.oauth2.model.RegisteredClientFields.INITIATE_LOGIN_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.JWKS;
import static org.mitre.oauth2.model.RegisteredClientFields.JWKS_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.LOGO_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.POLICY_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.POST_LOGOUT_REDIRECT_URIS;
import static org.mitre.oauth2.model.RegisteredClientFields.REDIRECT_URIS;
import static org.mitre.oauth2.model.RegisteredClientFields.REGISTRATION_ACCESS_TOKEN;
import static org.mitre.oauth2.model.RegisteredClientFields.REGISTRATION_CLIENT_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.REQUEST_OBJECT_SIGNING_ALG;
import static org.mitre.oauth2.model.RegisteredClientFields.REQUEST_URIS;
import static org.mitre.oauth2.model.RegisteredClientFields.REQUIRE_AUTH_TIME;
import static org.mitre.oauth2.model.RegisteredClientFields.RESPONSE_TYPES;
import static org.mitre.oauth2.model.RegisteredClientFields.SCOPE;
import static org.mitre.oauth2.model.RegisteredClientFields.SECTOR_IDENTIFIER_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.SOFTWARE_STATEMENT;
import static org.mitre.oauth2.model.RegisteredClientFields.SUBJECT_TYPE;
import static org.mitre.oauth2.model.RegisteredClientFields.TOKEN_ENDPOINT_AUTH_METHOD;
import static org.mitre.oauth2.model.RegisteredClientFields.TOKEN_ENDPOINT_AUTH_SIGNING_ALG;
import static org.mitre.oauth2.model.RegisteredClientFields.TOS_URI;
import static org.mitre.oauth2.model.RegisteredClientFields.USERINFO_ENCRYPTED_RESPONSE_ALG;
import static org.mitre.oauth2.model.RegisteredClientFields.USERINFO_ENCRYPTED_RESPONSE_ENC;
import static org.mitre.oauth2.model.RegisteredClientFields.USERINFO_SIGNED_RESPONSE_ALG;

/**
 * @author Michael Jett &lt;mjett@mitre.org&gt;
 */

@Controller
@RequestMapping(&quot;/&quot; + ClientAPI.URL)
@PreAuthorize(&quot;hasRole('ROLE_USER')&quot;)
<span class="nc" id="L129">public class ClientAPI {</span>

	public static final String URL = RootController.API_URL + &quot;/clients&quot;;

	@Autowired
	private ClientDetailsEntityService clientService;

	@Autowired
	private ClientLogoLoadingService clientLogoLoadingService;

	@Autowired
	@Qualifier(&quot;clientAssertionValidator&quot;)
	private AssertionValidator assertionValidator;

<span class="nc" id="L143">	private JsonParser parser = new JsonParser();</span>

<span class="nc" id="L145">	private Gson gson = new GsonBuilder()</span>
<span class="nc" id="L146">			.serializeNulls()</span>
<span class="nc" id="L147">			.registerTypeAdapter(JWSAlgorithm.class, new JsonDeserializer&lt;Algorithm&gt;() {</span>
				@Override
				public JWSAlgorithm deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L150" title="All 2 branches missed.">					if (json.isJsonPrimitive()) {</span>
<span class="nc" id="L151">						return JWSAlgorithm.parse(json.getAsString());</span>
					} else {
<span class="nc" id="L153">						return null;</span>
					}
				}
			})
<span class="nc" id="L157">			.registerTypeAdapter(JWEAlgorithm.class, new JsonDeserializer&lt;Algorithm&gt;() {</span>
				@Override
				public JWEAlgorithm deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L160" title="All 2 branches missed.">					if (json.isJsonPrimitive()) {</span>
<span class="nc" id="L161">						return JWEAlgorithm.parse(json.getAsString());</span>
					} else {
<span class="nc" id="L163">						return null;</span>
					}
				}
			})
<span class="nc" id="L167">			.registerTypeAdapter(EncryptionMethod.class, new JsonDeserializer&lt;Algorithm&gt;() {</span>
				@Override
				public EncryptionMethod deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L170" title="All 2 branches missed.">					if (json.isJsonPrimitive()) {</span>
<span class="nc" id="L171">						return EncryptionMethod.parse(json.getAsString());</span>
					} else {
<span class="nc" id="L173">						return null;</span>
					}
				}
			})
<span class="nc" id="L177">			.registerTypeAdapter(JWKSet.class, new JsonDeserializer&lt;JWKSet&gt;() {</span>
				@Override
				public JWKSet deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L180" title="All 2 branches missed.">					if (json.isJsonObject()) {</span>
						try {
<span class="nc" id="L182">							return JWKSet.parse(json.toString());</span>
<span class="nc" id="L183">						} catch (ParseException e) {</span>
<span class="nc" id="L184">							return null;</span>
						}
					} else {
<span class="nc" id="L187">						return null;</span>
					}
				}
			})
<span class="nc" id="L191">			.registerTypeAdapter(JWT.class, new JsonDeserializer&lt;JWT&gt;() {</span>
				@Override
				public JWT deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L194" title="All 2 branches missed.">					if (json.isJsonPrimitive()) {</span>
						try {
<span class="nc" id="L196">							return JWTParser.parse(json.getAsString());</span>
<span class="nc" id="L197">						} catch (ParseException e) {</span>
<span class="nc" id="L198">							return null;</span>
						}
					} else {
<span class="nc" id="L201">						return null;</span>
					}
				}
			})
<span class="nc" id="L205">			.registerTypeAdapter(PKCEAlgorithm.class, new JsonDeserializer&lt;Algorithm&gt;() {</span>
				@Override
				public PKCEAlgorithm deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
<span class="nc bnc" id="L208" title="All 2 branches missed.">					if (json.isJsonPrimitive()) {</span>
<span class="nc" id="L209">						return PKCEAlgorithm.parse(json.getAsString());</span>
					} else {
<span class="nc" id="L211">						return null;</span>
					}
				}
			})
<span class="nc" id="L215">			.setDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;)</span>
<span class="nc" id="L216">			.create();</span>

	/**
	 * Logger for this class
	 */
<span class="nc" id="L221">	private static final Logger logger = LoggerFactory.getLogger(ClientAPI.class);</span>

	/**
	 * Get a list of all clients
	 * @param modelAndView
	 * @return
	 */
	@RequestMapping(method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public String apiGetAllClients(Model model, Authentication auth) {

<span class="nc" id="L231">		Collection&lt;ClientDetailsEntity&gt; clients = clientService.getAllClients();</span>
<span class="nc" id="L232">		model.addAttribute(JsonEntityView.ENTITY, clients);</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">		if (AuthenticationUtilities.isAdmin(auth)) {</span>
<span class="nc" id="L235">			return ClientEntityViewForAdmins.VIEWNAME;</span>
		} else {
<span class="nc" id="L237">			return ClientEntityViewForUsers.VIEWNAME;</span>
		}
	}

	/**
	 * Create a new client
	 * @param json
	 * @param m
	 * @param principal
	 * @return
	 */
	@PreAuthorize(&quot;hasRole('ROLE_ADMIN')&quot;)
	@RequestMapping(method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String apiAddClient(@RequestBody String jsonString, Model m, Authentication auth) {

<span class="nc" id="L252">		JsonObject json = null;</span>
<span class="nc" id="L253">		ClientDetailsEntity client = null;</span>

		try {
<span class="nc" id="L256">			json = parser.parse(jsonString).getAsJsonObject();</span>
<span class="nc" id="L257">			client = gson.fromJson(json, ClientDetailsEntity.class);</span>
<span class="nc" id="L258">			client = validateSoftwareStatement(client);</span>
<span class="nc" id="L259">		} catch (JsonSyntaxException e) {</span>
<span class="nc" id="L260">			logger.error(&quot;apiAddClient failed due to JsonSyntaxException&quot;, e);</span>
<span class="nc" id="L261">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L262">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not save new client. The server encountered a JSON syntax exception. Contact a system administrator for assistance.&quot;);</span>
<span class="nc" id="L263">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L264">		} catch (IllegalStateException e) {</span>
<span class="nc" id="L265">			logger.error(&quot;apiAddClient failed due to IllegalStateException&quot;, e);</span>
<span class="nc" id="L266">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L267">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not save new client. The server encountered an IllegalStateException. Refresh and try again - if the problem persists, contact a system administrator for assistance.&quot;);</span>
<span class="nc" id="L268">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L269">		} catch (ValidationException e) {</span>
<span class="nc" id="L270">			logger.error(&quot;apiUpdateClient failed due to ValidationException&quot;, e);</span>
<span class="nc" id="L271">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L272">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not update client. The server encountered a ValidationException.&quot;);</span>
<span class="nc" id="L273">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L274">		}</span>

		// if they leave the client identifier empty, force it to be generated
<span class="nc bnc" id="L277" title="All 2 branches missed.">		if (Strings.isNullOrEmpty(client.getClientId())) {</span>
<span class="nc" id="L278">			client = clientService.generateClientId(client);</span>
		}

<span class="nc bnc" id="L281" title="All 2 branches missed.">		if (client.getTokenEndpointAuthMethod() == null ||</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">				client.getTokenEndpointAuthMethod().equals(AuthMethod.NONE)) {</span>
			// we shouldn't have a secret for this client

<span class="nc" id="L285">			client.setClientSecret(null);</span>

<span class="nc bnc" id="L287" title="All 2 branches missed.">		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_BASIC)</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_POST)</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_JWT)) {</span>

			// if they've asked for us to generate a client secret (or they left it blank but require one), do so here
<span class="nc bnc" id="L292" title="All 4 branches missed.">			if (json.has(&quot;generateClientSecret&quot;) &amp;&amp; json.get(&quot;generateClientSecret&quot;).getAsBoolean()</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">					|| Strings.isNullOrEmpty(client.getClientSecret())) {</span>
<span class="nc" id="L294">				client = clientService.generateClientSecret(client);</span>
			}

<span class="nc bnc" id="L297" title="All 2 branches missed.">		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY)) {</span>

<span class="nc bnc" id="L299" title="All 4 branches missed.">			if (Strings.isNullOrEmpty(client.getJwksUri()) &amp;&amp; client.getJwks() == null) {</span>
<span class="nc" id="L300">				logger.error(&quot;tried to create client with private key auth but no private key&quot;);</span>
<span class="nc" id="L301">				m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L302">				m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Can not create a client with private key authentication without registering a key via the JWK Set URI or JWK Set Value.&quot;);</span>
<span class="nc" id="L303">				return JsonErrorView.VIEWNAME;</span>
			}

			// otherwise we shouldn't have a secret for this client
<span class="nc" id="L307">			client.setClientSecret(null);</span>

		} else {

<span class="nc" id="L311">			logger.error(&quot;unknown auth method&quot;);</span>
<span class="nc" id="L312">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L313">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Unknown auth method requested&quot;);</span>
<span class="nc" id="L314">			return JsonErrorView.VIEWNAME;</span>


		}

<span class="nc" id="L319">		client.setDynamicallyRegistered(false);</span>

		try {
<span class="nc" id="L322">			ClientDetailsEntity newClient = clientService.saveNewClient(client);</span>
<span class="nc" id="L323">			m.addAttribute(JsonEntityView.ENTITY, newClient);</span>

<span class="nc bnc" id="L325" title="All 2 branches missed.">			if (AuthenticationUtilities.isAdmin(auth)) {</span>
<span class="nc" id="L326">				return ClientEntityViewForAdmins.VIEWNAME;</span>
			} else {
<span class="nc" id="L328">				return ClientEntityViewForUsers.VIEWNAME;</span>
			}
<span class="nc" id="L330">		} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L331">			logger.error(&quot;Unable to save client: {}&quot;, e.getMessage());</span>
<span class="nc" id="L332">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L333">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Unable to save client: &quot; + e.getMessage());</span>
<span class="nc" id="L334">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L335">		} catch (PersistenceException e) {</span>
<span class="nc" id="L336">			Throwable cause = e.getCause();</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">			if (cause instanceof DatabaseException) {</span>
<span class="nc" id="L338">				Throwable databaseExceptionCause = cause.getCause();</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">				if(databaseExceptionCause instanceof SQLIntegrityConstraintViolationException) {</span>
<span class="nc" id="L340">					logger.error(&quot;apiAddClient failed; duplicate client id entry found: {}&quot;, client.getClientId());</span>
<span class="nc" id="L341">					m.addAttribute(HttpCodeView.CODE, HttpStatus.CONFLICT);</span>
<span class="nc" id="L342">					m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Unable to save client. Duplicate client id entry found: &quot; + client.getClientId());</span>
<span class="nc" id="L343">					return JsonErrorView.VIEWNAME;</span>
				}
			}
<span class="nc" id="L346">			throw e;</span>
		}
	}

	/**
	 * Update an existing client
	 * @param id
	 * @param jsonString
	 * @param m
	 * @param principal
	 * @return
	 */
	@PreAuthorize(&quot;hasRole('ROLE_ADMIN')&quot;)
	@RequestMapping(value=&quot;/{id}&quot;, method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
	public String apiUpdateClient(@PathVariable(&quot;id&quot;) Long id, @RequestBody String jsonString, Model m, Authentication auth) {

<span class="nc" id="L362">		JsonObject json = null;</span>
<span class="nc" id="L363">		ClientDetailsEntity client = null;</span>

		try {
			// parse the client passed in (from JSON) and fetch the old client from the store
<span class="nc" id="L367">			json = parser.parse(jsonString).getAsJsonObject();</span>
<span class="nc" id="L368">			client = gson.fromJson(json, ClientDetailsEntity.class);</span>
<span class="nc" id="L369">			client = validateSoftwareStatement(client);</span>
<span class="nc" id="L370">		} catch (JsonSyntaxException e) {</span>
<span class="nc" id="L371">			logger.error(&quot;apiUpdateClient failed due to JsonSyntaxException&quot;, e);</span>
<span class="nc" id="L372">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L373">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not update client. The server encountered a JSON syntax exception. Contact a system administrator for assistance.&quot;);</span>
<span class="nc" id="L374">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L375">		} catch (IllegalStateException e) {</span>
<span class="nc" id="L376">			logger.error(&quot;apiUpdateClient failed due to IllegalStateException&quot;, e);</span>
<span class="nc" id="L377">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L378">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not update client. The server encountered an IllegalStateException. Refresh and try again - if the problem persists, contact a system administrator for assistance.&quot;);</span>
<span class="nc" id="L379">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L380">		} catch (ValidationException e) {</span>
<span class="nc" id="L381">			logger.error(&quot;apiUpdateClient failed due to ValidationException&quot;, e);</span>
<span class="nc" id="L382">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L383">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not update client. The server encountered a ValidationException.&quot;);</span>
<span class="nc" id="L384">			return JsonErrorView.VIEWNAME;</span>
<span class="nc" id="L385">		}</span>

<span class="nc" id="L387">		ClientDetailsEntity oldClient = clientService.getClientById(id);</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (oldClient == null) {</span>
<span class="nc" id="L390">			logger.error(&quot;apiUpdateClient failed; client with id &quot; + id + &quot; could not be found.&quot;);</span>
<span class="nc" id="L391">			m.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND);</span>
<span class="nc" id="L392">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Could not update client. The requested client with id &quot; + id + &quot;could not be found.&quot;);</span>
<span class="nc" id="L393">			return JsonErrorView.VIEWNAME;</span>
		}

		// if they leave the client identifier empty, force it to be generated
<span class="nc bnc" id="L397" title="All 2 branches missed.">		if (Strings.isNullOrEmpty(client.getClientId())) {</span>
<span class="nc" id="L398">			client = clientService.generateClientId(client);</span>
		}

<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (client.getTokenEndpointAuthMethod() == null ||</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">				client.getTokenEndpointAuthMethod().equals(AuthMethod.NONE)) {</span>
			// we shouldn't have a secret for this client

<span class="nc" id="L405">			client.setClientSecret(null);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_BASIC)</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_POST)</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">				|| client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_JWT)) {</span>

			// if they've asked for us to generate a client secret (or they left it blank but require one), do so here
<span class="nc bnc" id="L412" title="All 4 branches missed.">			if (json.has(&quot;generateClientSecret&quot;) &amp;&amp; json.get(&quot;generateClientSecret&quot;).getAsBoolean()</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">					|| Strings.isNullOrEmpty(client.getClientSecret())) {</span>
<span class="nc" id="L414">				client = clientService.generateClientSecret(client);</span>
			}

<span class="nc bnc" id="L417" title="All 2 branches missed.">		} else if (client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY)) {</span>

<span class="nc bnc" id="L419" title="All 4 branches missed.">			if (Strings.isNullOrEmpty(client.getJwksUri()) &amp;&amp; client.getJwks() == null) {</span>
<span class="nc" id="L420">				logger.error(&quot;tried to create client with private key auth but no private key&quot;);</span>
<span class="nc" id="L421">				m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L422">				m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Can not create a client with private key authentication without registering a key via the JWK Set URI or JWK Set Value.&quot;);</span>
<span class="nc" id="L423">				return JsonErrorView.VIEWNAME;</span>
			}

			// otherwise we shouldn't have a secret for this client
<span class="nc" id="L427">			client.setClientSecret(null);</span>

		} else {

<span class="nc" id="L431">			logger.error(&quot;unknown auth method&quot;);</span>
<span class="nc" id="L432">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L433">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Unknown auth method requested&quot;);</span>
<span class="nc" id="L434">			return JsonErrorView.VIEWNAME;</span>


		}

		try {
<span class="nc" id="L440">			ClientDetailsEntity newClient = clientService.updateClient(oldClient, client);</span>
<span class="nc" id="L441">			m.addAttribute(JsonEntityView.ENTITY, newClient);</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">			if (AuthenticationUtilities.isAdmin(auth)) {</span>
<span class="nc" id="L444">				return ClientEntityViewForAdmins.VIEWNAME;</span>
			} else {
<span class="nc" id="L446">				return ClientEntityViewForUsers.VIEWNAME;</span>
			}
<span class="nc" id="L448">		} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L449">			logger.error(&quot;Unable to save client: {}&quot;, e.getMessage());</span>
<span class="nc" id="L450">			m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);</span>
<span class="nc" id="L451">			m.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;Unable to save client: &quot; + e.getMessage());</span>
<span class="nc" id="L452">			return JsonErrorView.VIEWNAME;</span>
		}
	}

	/**
	 * Delete a client
	 * @param id
	 * @param modelAndView
	 * @return
	 */
	@PreAuthorize(&quot;hasRole('ROLE_ADMIN')&quot;)
	@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.DELETE)
	public String apiDeleteClient(@PathVariable(&quot;id&quot;) Long id, ModelAndView modelAndView) {

<span class="nc" id="L466">		ClientDetailsEntity client = clientService.getClientById(id);</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">		if (client == null) {</span>
<span class="nc" id="L469">			logger.error(&quot;apiDeleteClient failed; client with id &quot; + id + &quot; could not be found.&quot;);</span>
<span class="nc" id="L470">			modelAndView.getModelMap().put(HttpCodeView.CODE, HttpStatus.NOT_FOUND);</span>
<span class="nc" id="L471">			modelAndView.getModelMap().put(JsonErrorView.ERROR_MESSAGE, &quot;Could not delete client. The requested client with id &quot; + id + &quot;could not be found.&quot;);</span>
<span class="nc" id="L472">			return JsonErrorView.VIEWNAME;</span>
		} else {
<span class="nc" id="L474">			modelAndView.getModelMap().put(HttpCodeView.CODE, HttpStatus.OK);</span>
<span class="nc" id="L475">			clientService.deleteClient(client);</span>
		}

<span class="nc" id="L478">		return HttpCodeView.VIEWNAME;</span>
	}


	/**
	 * Get an individual client
	 * @param id
	 * @param modelAndView
	 * @return
	 */
	@RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	public String apiShowClient(@PathVariable(&quot;id&quot;) Long id, Model model, Authentication auth) {

<span class="nc" id="L491">		ClientDetailsEntity client = clientService.getClientById(id);</span>

<span class="nc bnc" id="L493" title="All 2 branches missed.">		if (client == null) {</span>
<span class="nc" id="L494">			logger.error(&quot;apiShowClient failed; client with id &quot; + id + &quot; could not be found.&quot;);</span>
<span class="nc" id="L495">			model.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND);</span>
<span class="nc" id="L496">			model.addAttribute(JsonErrorView.ERROR_MESSAGE, &quot;The requested client with id &quot; + id + &quot; could not be found.&quot;);</span>
<span class="nc" id="L497">			return JsonErrorView.VIEWNAME;</span>
		}

<span class="nc" id="L500">		model.addAttribute(JsonEntityView.ENTITY, client);</span>

<span class="nc bnc" id="L502" title="All 2 branches missed.">		if (AuthenticationUtilities.isAdmin(auth)) {</span>
<span class="nc" id="L503">			return ClientEntityViewForAdmins.VIEWNAME;</span>
		} else {
<span class="nc" id="L505">			return ClientEntityViewForUsers.VIEWNAME;</span>
		}
	}

	/**
	 * Get the logo image for a client
	 * @param id
	 */
	@RequestMapping(value = &quot;/{id}/logo&quot;, method=RequestMethod.GET, produces = { MediaType.IMAGE_GIF_VALUE, MediaType.IMAGE_JPEG_VALUE, MediaType.IMAGE_PNG_VALUE })
	public ResponseEntity&lt;byte[]&gt; getClientLogo(@PathVariable(&quot;id&quot;) Long id, Model model) {

<span class="nc" id="L516">		ClientDetailsEntity client = clientService.getClientById(id);</span>

<span class="nc bnc" id="L518" title="All 2 branches missed.">		if (client == null) {</span>
<span class="nc" id="L519">			return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		} else if (Strings.isNullOrEmpty(client.getLogoUri())) {</span>
<span class="nc" id="L521">			return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);</span>
		} else {
			// get the image from cache
<span class="nc" id="L524">			CachedImage image = clientLogoLoadingService.getLogo(client);</span>

<span class="nc" id="L526">			HttpHeaders headers = new HttpHeaders();</span>
<span class="nc" id="L527">			headers.setContentType(MediaType.parseMediaType(image.getContentType()));</span>
<span class="nc" id="L528">			headers.setContentLength(image.getLength());</span>

<span class="nc" id="L530">			return new ResponseEntity&lt;&gt;(image.getData(), headers, HttpStatus.OK);</span>
		}
	}

	private ClientDetailsEntity validateSoftwareStatement(ClientDetailsEntity newClient) throws ValidationException {
<span class="nc bnc" id="L535" title="All 2 branches missed.">		if (newClient.getSoftwareStatement() != null) {</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">			if (assertionValidator.isValid(newClient.getSoftwareStatement())) {</span>
				// we have a software statement and its envelope passed all the checks from our validator

				// swap out all of the client's fields for the associated parts of the software statement
				try {
<span class="nc" id="L541">					JWTClaimsSet claimSet = newClient.getSoftwareStatement().getJWTClaimsSet();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">					for (String claim : claimSet.getClaims().keySet()) {</span>
<span class="nc bnc" id="L543" title="All 154 branches missed.">						switch (claim) {</span>
							case SOFTWARE_STATEMENT:
<span class="nc" id="L545">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't include another software statement&quot;, HttpStatus.BAD_REQUEST);</span>
							case CLAIMS_REDIRECT_URIS:
<span class="nc" id="L547">								newClient.setClaimsRedirectUris(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L548">								break;</span>
							case CLIENT_SECRET_EXPIRES_AT:
<span class="nc" id="L550">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't include a client secret expiration time&quot;, HttpStatus.BAD_REQUEST);</span>
							case CLIENT_ID_ISSUED_AT:
<span class="nc" id="L552">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't include a client ID issuance time&quot;, HttpStatus.BAD_REQUEST);</span>
							case REGISTRATION_CLIENT_URI:
<span class="nc" id="L554">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't include a client configuration endpoint&quot;, HttpStatus.BAD_REQUEST);</span>
							case REGISTRATION_ACCESS_TOKEN:
<span class="nc" id="L556">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't include a client registration access token&quot;, HttpStatus.BAD_REQUEST);</span>
							case REQUEST_URIS:
<span class="nc" id="L558">								newClient.setRequestUris(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L559">								break;</span>
							case POST_LOGOUT_REDIRECT_URIS:
<span class="nc" id="L561">								newClient.setPostLogoutRedirectUris(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L562">								break;</span>
							case INITIATE_LOGIN_URI:
<span class="nc" id="L564">								newClient.setInitiateLoginUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L565">								break;</span>
							case DEFAULT_ACR_VALUES:
<span class="nc" id="L567">								newClient.setDefaultACRvalues(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L568">								break;</span>
							case REQUIRE_AUTH_TIME:
<span class="nc" id="L570">								newClient.setRequireAuthTime(claimSet.getBooleanClaim(claim));</span>
<span class="nc" id="L571">								break;</span>
							case DEFAULT_MAX_AGE:
<span class="nc" id="L573">								newClient.setDefaultMaxAge(claimSet.getIntegerClaim(claim));</span>
<span class="nc" id="L574">								break;</span>
							case TOKEN_ENDPOINT_AUTH_SIGNING_ALG:
<span class="nc" id="L576">								newClient.setTokenEndpointAuthSigningAlg(JWSAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L577">								break;</span>
							case ID_TOKEN_ENCRYPTED_RESPONSE_ENC:
<span class="nc" id="L579">								newClient.setIdTokenEncryptedResponseEnc(EncryptionMethod.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L580">								break;</span>
							case ID_TOKEN_ENCRYPTED_RESPONSE_ALG:
<span class="nc" id="L582">								newClient.setIdTokenEncryptedResponseAlg(JWEAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L583">								break;</span>
							case ID_TOKEN_SIGNED_RESPONSE_ALG:
<span class="nc" id="L585">								newClient.setIdTokenSignedResponseAlg(JWSAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L586">								break;</span>
							case USERINFO_ENCRYPTED_RESPONSE_ENC:
<span class="nc" id="L588">								newClient.setUserInfoEncryptedResponseEnc(EncryptionMethod.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L589">								break;</span>
							case USERINFO_ENCRYPTED_RESPONSE_ALG:
<span class="nc" id="L591">								newClient.setUserInfoEncryptedResponseAlg(JWEAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L592">								break;</span>
							case USERINFO_SIGNED_RESPONSE_ALG:
<span class="nc" id="L594">								newClient.setUserInfoSignedResponseAlg(JWSAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L595">								break;</span>
							case REQUEST_OBJECT_SIGNING_ALG:
<span class="nc" id="L597">								newClient.setRequestObjectSigningAlg(JWSAlgorithm.parse(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L598">								break;</span>
							case SUBJECT_TYPE:
<span class="nc" id="L600">								newClient.setSubjectType(SubjectType.getByValue(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L601">								break;</span>
							case SECTOR_IDENTIFIER_URI:
<span class="nc" id="L603">								newClient.setSectorIdentifierUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L604">								break;</span>
							case APPLICATION_TYPE:
<span class="nc" id="L606">								newClient.setApplicationType(AppType.getByValue(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L607">								break;</span>
							case JWKS_URI:
<span class="nc" id="L609">								newClient.setJwksUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L610">								break;</span>
							case JWKS:
<span class="nc" id="L612">								newClient.setJwks(JWKSet.parse(claimSet.getJSONObjectClaim(claim).toJSONString()));</span>
<span class="nc" id="L613">								break;</span>
							case POLICY_URI:
<span class="nc" id="L615">								newClient.setPolicyUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L616">								break;</span>
							case RESPONSE_TYPES:
<span class="nc" id="L618">								newClient.setResponseTypes(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L619">								break;</span>
							case GRANT_TYPES:
<span class="nc" id="L621">								newClient.setGrantTypes(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L622">								break;</span>
							case SCOPE:
<span class="nc" id="L624">								newClient.setScope(OAuth2Utils.parseParameterList(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L625">								break;</span>
							case TOKEN_ENDPOINT_AUTH_METHOD:
<span class="nc" id="L627">								newClient.setTokenEndpointAuthMethod(AuthMethod.getByValue(claimSet.getStringClaim(claim)));</span>
<span class="nc" id="L628">								break;</span>
							case TOS_URI:
<span class="nc" id="L630">								newClient.setTosUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L631">								break;</span>
							case CONTACTS:
<span class="nc" id="L633">								newClient.setContacts(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L634">								break;</span>
							case LOGO_URI:
<span class="nc" id="L636">								newClient.setLogoUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L637">								break;</span>
							case CLIENT_URI:
<span class="nc" id="L639">								newClient.setClientUri(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L640">								break;</span>
							case CLIENT_NAME:
<span class="nc" id="L642">								newClient.setClientName(claimSet.getStringClaim(claim));</span>
<span class="nc" id="L643">								break;</span>
							case REDIRECT_URIS:
<span class="nc" id="L645">								newClient.setRedirectUris(Sets.newHashSet(claimSet.getStringListClaim(claim)));</span>
<span class="nc" id="L646">								break;</span>
							case CLIENT_SECRET:
<span class="nc" id="L648">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't contain client secret&quot;, HttpStatus.BAD_REQUEST);</span>
							case CLIENT_ID:
<span class="nc" id="L650">								throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement can't contain client ID&quot;, HttpStatus.BAD_REQUEST);</span>

							default:
<span class="nc" id="L653">								logger.warn(&quot;Software statement contained unknown field: &quot; + claim + &quot; with value &quot; + claimSet.getClaim(claim));</span>
								break;
						}
<span class="nc" id="L656">					}</span>

<span class="nc" id="L658">					return newClient;</span>
<span class="nc" id="L659">				} catch (ParseException e) {</span>
<span class="nc" id="L660">					throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement claims didn't parse&quot;, HttpStatus.BAD_REQUEST);</span>
				}
			} else {
<span class="nc" id="L663">				throw new ValidationException(&quot;invalid_client_metadata&quot;, &quot;Software statement rejected by validator&quot;, HttpStatus.BAD_REQUEST);</span>
			}
		} else {
			// nothing to see here, carry on
<span class="nc" id="L667">			return newClient;</span>
		}

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>